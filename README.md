# clever_backend_task_14_spring_boot

## Задача

Реализация на Spring boot 3.2.*

1. Создать Web приложение учёта домов и жильцов
2. 3 сущности: House, Person, HouseHistory
3. Система должна предоставлять REST API для выполнения следующих операций:

- CRUD для House
    - В GET запросах не выводить информацию о Person
- CRUD для Person
    - В GET запросах не выводить информацию о House
- Для GET операций использовать pagination (default size: 15)
- GET для получения всех Person когда-либо проживавших в доме
- GET для получения всех Person когда-либо владевших домом
- GET для получения всех House где проживал Person
- GET для получения всех House которыми когда-либо владел Person

### House:

1. У House обязаны быть поля id, uuid, area, country, city, street, number, create_date
2. House может иметь множество жильцов (0-n)
3. У House может быть множество владельцев (0-n)
4. create_date устанавливается один раз при создании

### Person:

1. У Person обязаны быть id, uuid, name, surname, sex, passport_series, passport_number, create_date, update_date
2. Person обязан жить только в одном доме и не может быть бездомным
3. Person не обязан владеть хоть одним домом и может владеть множеством домов
4. Сочетание passport_series и passport_number уникально
5. sex должен быть [Male, Female]
6. Все связи обеспечить через id
7. Не возвращать id пользователям сервисов, для этого предназначено поле uuid
8. create_date устанавливается один раз при создании
9. update_date устанавливается при создании и изменяется каждый раз, когда меняется информация о Person. При этом, если
   запрос не изменяет информации, поле не должно обновиться

### HouseHistory:

У HouseHistory обязаны быть (id, house_id, person_id, date, type)

1. type [OWNER, TENANT]
    - Создать свой тип данных в БД
    - Хранить как enum в коде
2. При смене места жительства добавляем запись в HouseHistory [type = TENANT], с текущей датой
3. При смене владельца, добавляем запись в HouseHistory [type = OWNER], с текущей датой
4.
    * Реализовать через триггер в БД
5.
    * Если используется миграция, дописать новый changeset, а не исправлять существующие.

Добавляем кэш из задания по рефлексии на сервисный слой House и Person.

1. Добавляем Integration тесты, чтобы кэш работал в многопоточной среде.
2. Делаем экзекутор на 6 потоков и параллельно вызываем сервисный слой (GET\POST\PUT\DELETE) и проверяем, что результат
   соответствует ожиданиям.
3. Используем H2 или *testcontainers

* Добавляем swagger (OPEN API)
    1. ** Добавляем starter:
    2. **Реализовываем мультипроект
    3. **Реализовываем свой cache-starter (из задания по рефлексии)
    4. **Добавляем таску с build в mavenLocal
    5. **Добавляем стартер в основное приложение, через mavelLocal
    6. **Удаляем все классы из основного приложения

### Примечание:

1. Ограничения и нормализацию сделать на своё усмотрение
2. Поля представлены для хранения в базе данных. В коде могут отличаться

### Обязательно:

1. GET для всех Person проживающих в House
2. GET для всех House, владельцем которых является Person
3. Конфигурационный файл: application.yml
4. Скрипты для создания таблиц должны лежать в classpath:db/
5. create_date, update_date - возвращать в формате ISO-8601 (https://en.wikipedia.org/wiki/ISO_8601). Пример:
   2018-08-29T06:12:15.156.
6. Добавить 5 домов и 10 жильцов. Один дом без жильцов и как минимум в 1 доме больше 1 владельца
7. Использовать репозиторий с JDBC Template для одного метода.

### Дополнительно:

1. *Добавить миграцию
2. *Полнотекстовый поиск (любое текстовое поле) для House
3. *Полнотекстовый поиск (любое текстовое поле) для Person
5. **PATCH для Person и House

### Самостоятельно:

1. Изучить отношения: OneToOne, OneToMany, ManyToOne, ManyToMany;
2. !!! Изучить Hibernate Persistence Context;
3. !!! Изучить кеширование в hibernate;

### Требования к приложению

1. Версия JDK: 17 – используйте Streams, java.time.* и т. д., где это возможно.
2. Корень пакетов приложений: ru.clevertec.house.
3. Можно использовать любой широко используемый пул соединений.
4. Для доступа к данным следует использовать шаблон Spring JDBC.
5. Используйте транзакции там, где это необходимо.
6. Соглашение Java Code является обязательным (исключение: размер поля – 120 символов).
7. Инструмент сборки: Gradle, последняя версия.
8. Веб-сервер: Apache Tomcat.
9. Контейнер приложения: Spring IoC. Spring Framework, последняя версия.
10. База данных: PostgreSQL, последняя версия.
11. Тестирование: JUnit 5.+, Mockito.
12. Сервисный уровень должен быть покрыт юнит-тестами не менее чем на 80%.
13. Уровень репозитория следует тестировать с помощью интеграционных тестов со встроенной в память базой данных или
    тестовыми контейнерами.
14. В качестве картографа используйте Mapstruct.
16. Используйте ломбок.

### Общие требования

1. Код должен быть чистым и не должен содержать никаких конструкций, предназначенных для разработчиков.
2. Приложение должно быть спроектировано и написано с учетом принципов OOD и SOLID.
3. Код должен содержать ценные комментарии, где это необходимо.
4. Публичные API должны быть задокументированы (Javadoc).
5. Следует использовать четкую многоуровневую структуру с определением обязанностей каждого прикладного уровня.
6. JSON следует использовать в качестве формата сообщений связи клиент-сервер.
7. Должен быть реализован удобный механизм обработки ошибок/исключений: все ошибки должны быть значимыми на серверной
   стороне.
   Пример: обработка ошибки 404:
   HTTP Status: 404
   response body

```http
{
 “errorMessage”: “Requested resource not found (uuid = f4fe3df1-22cd-49ce-a54d-86f55a7f372e)”,
 “errorCode”: 40401
 }

```

где “errorCode” — ваш собственный код (он может основываться на статусе http и запрошенном ресурсе — человеке или доме)

9. Абстракцию следует использовать везде, чтобы избежать дублирования кода.
10. Должно быть реализовано несколько конфигураций (минимум две — dev и prod).


